###  Типы данных в Python

#### Короткий ответ
- **Изменяемые (mutable):** `list`, `dict`, `set`
- **Неизменяемые (immutable):** `int`, `float`, `str`, `tuple`, `bytes`, `bool`, `None`  

#### Развернутый ответ
В Python все типы данных делятся на **изменяемые (mutable)** и **неизменяемые (immutable)**, что определяет их поведение при работе с переменными, передаче в функции и использовании в структурах данных.

**1. Изменяемые типы (mutable)**  
Можно модифицировать после создания, сохраняя тот же объект в памяти:
- `list` — списки (`[1, 2, 3]`)
- `dict` — словари (`{'key': 'value'}`)
- `set` — множества (`{1, 2, 3}`)


Пример:
```python
lst = [1, 2, 3]
lst[0] = 100  # Изменение элемента
lst.append(4) # Добавление элемента
print(lst)    # [100, 2, 3, 4] (объект остался тем же)
```

**2. Неизменяемые типы (immutable)**  
Нельзя изменить после создания. Любая операция "изменения" создаёт новый объект:
- Числа: `int`, `float`
- Строки: `str`
- Кортежи: `tuple`
- Байты: `bytes`
- Логический тип: `bool`
- Специальное значение: `None`

Пример:
```python
s = "hello"
# s[0] = "H"  # TypeError: 'str' does not support item assignment
new_s = s.replace("h", "H")  # Создаётся новая строка "Hello"

t = (1, 2, 3)
# t[0] = 100  # TypeError: 'tuple' object does not support item assignment
```

**3. Практические последствия**  
- **Изменяемые объекты** могут неожиданно изменяться при передаче в функции (передаются по ссылке).  
- **Неизменяемые объекты** безопасны для использования как ключи словаря (хэшируемы).  
- Операции с неизменяемыми типами часто требуют больше памяти (создают новые объекты).  


### Переменные в Python передаются по ссылке или по значению?
#### Короткий ответ
В Python передача аргументов происходит по присваиванию ссылки (pass-by-assignment). Для неизменяемых типов это работает как передача по значению (изменение не влияет на оригинал), а для изменяемых — как передача по ссылке (изменения затрагивают оригинал).

#### Развернутый ответ
В Python передача аргументов в функции происходит по ссылке на объект, но с важными нюансами, которые часто называют "передачей по присваиванию" (pass by assignment). Вот детальное объяснение:

1. **Основной механизм**
- Все переменные в Python — это ссылки на объекты
- При передаче в функцию передаётся копия ссылки на объект
- Изменения мутируемых объектов видны снаружи функции
- Изменения имени переменной (переприсваивание) не влияют на оригинал

2. **Пример с неизменяемыми (immutable) объектами**
```python
def modify_num(x):
    x += 10
    print("Внутри функции:", x)  # 15

num = 5
modify_num(num)
print("Снаружи:", num)  # 5 (не изменился)
```
Для `int`, `float`, `str`, `tuple` и других неизменяемых типов: при "изменении" создаётся новый объект, а оригинал остаётся нетронутым.

3. **Пример с изменяемыми (mutable) объектами**
```python
def modify_list(lst):
    lst.append(4)
    print("Внутри функции:", lst)  # [1, 2, 3, 4]

my_list = [1, 2, 3]
modify_list(my_list)
print("Снаружи:", my_list)  # [1, 2, 3, 4] (изменился!)
```
Для `list`, `dict`, `set` и других изменяемых типов: изменения объекта видны везде, где есть ссылки на него.

4. **Переприсваивание vs. изменение объекта**
```python
def reassign(lst):
    lst = [4, 5, 6]  # Создаётся новая локальная ссылка
    print("Внутри после переприсваивания:", lst)  # [4, 5, 6]

my_list = [1, 2, 3]
reassign(my_list)
print("Снаружи:", my_list)  # [1, 2, 3] (не изменился)
```
Переприсваивание (`=`) меняет, на какой объект ссылается переменная, но не изменяет оригинальный объект.

5. **Как работает передача аргументов**

| Действие                  | Изменяемый объект (list, dict) | Неизменяемый объект (int, str, tuple) |
|---------------------------|--------------------------------|----------------------------------------|
| Изменение содержимого     | Влияет на оригинал             | Невозможно (создаётся новый объект)    |
| Переприсваивание (`=`)     | Не влияет на оригинал          | Не влияет на оригинал                  |

6. **Практические следствия**
- Для изменяемых объектов используйте `copy()` или `deepcopy()`, если нужно избежать побочных эффектов:
```python
from copy import deepcopy

def safe_modify(lst):
    lst_copy = deepcopy(lst)
    lst_copy.append(100)
    return lst_copy
```
- Для возврата нескольких результатов предпочитайте возврат кортежа изменению входных параметров:
```python
def process_data(data):
    # Вместо изменения data
    return new_data, stats
```

7. **Сравнение с другими языками**
- Не похоже на передачу по значению (как в C), так как изменяемые объекты можно модифицировать
- Не похоже на передачу по ссылке (как в PHP), так как переприсваивание не влияет на оригинал
- Ближе всего к передаче указателя по значению (как в Java)

Таким образом, в Python аргументы передаются по ссылке на объект, но сама ссылка передаётся по значению, что объясняет все описанные выше поведения.

### Как выполняется интерполяция строк в Python?

#### Короткий ответ
Основные методы интерполяции:
- **f-строки**: `f"Привет, {name}"` (рекомендуемый способ)
- **Метод format()**: `"Привет, {}".format(name)`
- **Оператор %**: `"Привет, %s" % name` (устаревший)
- **String Template**: `Template("Привет, $name").substitute(name="Анна")`

#### Развернутый ответ

##### 1. F-строки (Python 3.6+)
Самый современный и рекомендуемый способ:
```python
name = "Анна"
age = 25

# Базовое использование
print(f"Привет, {name}! Тебе {age} лет.")

# С вычислениями
print(f"Через 5 лет тебе будет {age + 5} лет.")

# Форматирование чисел
print(f"Цена: {19.99:.2f} руб.")  # Цена: 19.99 руб.
```

##### 2. Метод format()
```python
# Позиционные аргументы
"Привет, {}! Тебе {} лет.".format(name, age)

# Именованные аргументы
"Имя: {name}, Возраст: {age}".format(name=name, age=age)

# Форматирование чисел
"Баланс: {:.2f}".format(123.456)  # Баланс: 123.46
```

##### 3. %-форматирование (устаревшее)
```python
"Привет, %s! Тебе %d лет." % (name, age)
"Процент: %.1f%%" % 99.5  # Процент: 99.5%
```

##### 4. String Template
```python
from string import Template
t = Template("Привет, $name! Тебе $age лет.")
print(t.substitute(name=name, age=age))
```

##### Продвинутые возможности f-строк
```python
# Вызов методов
print(f"Имя заглавными: {name.upper()}")

# Доступ к элементам
colors = ["красный", "зелёный", "синий"]
print(f"Первый цвет: {colors[0]}")

# Форматирование дат
from datetime import datetime
print(f"Сегодня: {datetime.now():%d.%m.%Y}")

# Специальные преобразования
print(f"{'текст'!r}")  # repr: 'текст'
print(f"{'текст'!a}")  # ascii-представление
```

##### Сравнение методов
| Метод              | Версии Python | Производительность | Читаемость |
|--------------------|---------------|--------------------|------------|
| f-строки           | 3.6+          | ⭐⭐⭐⭐⭐           | ⭐⭐⭐⭐⭐    |
| format()           | 2.6+          | ⭐⭐⭐⭐             | ⭐⭐⭐⭐      |
| %-форматирование   | Все           | ⭐⭐⭐              | ⭐⭐         |
| String Template    | Все           | ⭐⭐               | ⭐⭐⭐        |

**Рекомендации:**
1. Всегда используйте f-строки для Python 3.6+
2. Для сложных случаев или совместимости - метод format()
3. Избегайте %-оператора в новом коде
4. String Template полезен для пользовательских шаблонов



### Особенности копирования изменяемых объектов в Python 

#### Краткий ответ  
- **Поверхностное копирование** (`copy()`) создает новый объект, но вложенные объекты остаются ссылками.  
- **Глубокое копирование** (`deepcopy()`) рекурсивно копирует все вложенные объекты.  

#### Развернутый ответ  

**1. Поверхностное копирование (shallow copy)**  
Создает новый объект, но вкладывает в него ссылки на те же вложенные объекты.  

**Методы:**  
```python  
import copy  

# Для списков  
original = [1, [2, 3], 4]  
shallow_copy = original.copy()  # или copy.copy(original) или original[:]  

# Для словарей  
dict_original = {'a': [1, 2]}  
dict_copy = dict_original.copy()  
```  

**Особенности:**  
- Изменения вложенных изменяемых объектов затрагивают оригинал.  
- Быстрее глубокого копирования.  
- Достаточно для одноуровневых структур.  

**Пример:**  
```python  
original[1].append(5)  
print(shallow_copy)  # [1, [2, 3, 5], 4] - вложенный список изменился!  
```  

---  

**2. Глубокое копирование (deep copy)**  
Рекурсивно создает новые копии всех вложенных объектов.  

**Пример:**  
```python  
import copy  

original = [1, [2, 3], 4]  
deep_copy = copy.deepcopy(original)  

original[1].append(5)  
print(deep_copy)  # [1, [2, 3], 4] - копия осталась неизменной  
```  

**Особенности:**  
- Полная изоляция от изменений в оригинале.  
- Затратно по памяти и времени для сложных структур.  
- Может вызвать проблемы с циклическими ссылками.  

---  

**3. Особые случаи**  
- **Копирование сложных структур:**  
  ```python  
  data = {  
      'items': [1, 2, {'key': 'value'}],  
      'config': {'settings': [True, False]}  
  }  
  data_copy = copy.deepcopy(data)  
  ```  

- **Копирование пользовательских классов:**  
  ```python  
  class MyClass:  
      def __init__(self, x):  
          self.x = x  

  obj = MyClass([1, 2, 3])  
  obj_copy = copy.deepcopy(obj)  
  ```  

---  

**4. Различия методов копирования**  

| Метод                | Уровень             | Изменения в оригинале | Производительность |  
|----------------------|---------------------|-----------------------|--------------------|  
| Присваивание (`=`)   | Нет копирования     | Всегда видны          | Мгновенно          |  
| `.copy()` / `copy.copy()` | Поверхностное | Видны для вложенных   | Быстро             |  
| `copy.deepcopy()`     | Глубокое            | Не видны              | Медленно           |  

---  

**5. Рекомендации**  
- Используйте глубокое копирование для структур с вложенными изменяемыми объектами.  
- Для простых списков/словарей достаточно поверхностного копирования.  
- Избегайте глубокого копирования для объектов с циклическими ссылками.  
- Для пользовательских классов можно определить `__copy__` и `__deepcopy__`:  
  ```python  
  class MyClass:  
      def __init__(self, x):  
          self.x = x  

      def __copy__(self):  
          return MyClass(self.x.copy())  

      def __deepcopy__(self, memo):  
          return MyClass(copy.deepcopy(self.x, memo))  
  ```  

#### Доп. информация  
Правильное копирование особенно важно при работе с:  
- Многопоточными приложениями.  
- Изменяемыми аргументами функций (например, списки или словари по умолчанию).

